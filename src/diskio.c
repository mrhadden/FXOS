/*-----------------------------------------------------------------------*/
/* Low level disk I/O module skeleton for FatFs     (C)ChaN, 2019        */
/*-----------------------------------------------------------------------*/
/* If a working storage control module is available, it should be        */
/* attached to the FatFs via a glue function rather than modifying it.   */
/* This is an example of glue functions to attach various exsisting      */
/* storage control modules to the FatFs module with a defined API.       */
/*-----------------------------------------------------------------------*/
#include 	"fxkernel.h"

#if defined(USE_FX256_FMX) || defined(USE_FX256_U)


#include "ff/ff.h"			/* Obtains integer types */
#include "diskio.h"		/* Declarations of disk functions */
#include "fxdos.h"


static PFXDOSDEVICE diskioDevices[] = {NULL,NULL,NULL,NULL,NULL,NULL};


static CHAR fake_device_mbr[] = {0xEB,0x58,0x90,0x57,0x49,0x4E,0x49,0x4D,0x41,0x47,0x45,0x00,0x02,0x02,0x01,0x00,
		                     0x02,0x70,0x00,0x40,0x01,0xFD,0x01,0x00,0x08,0x00,0x01,0x00,0x00,0x00,0x00,0x00,
							 0x00,0x00,0x00,0x00,0x00,0x00,0x29,0x26,0x3D,0x98,0x54,0x20,0x20,0x20,0x20,0x20,
							 0x20,0x20,0x20,0x20,0x20,0x20,0x46,0x41,0x54,0x31,0x32,0x20,0x20,0x20,0x00,0x00,
							 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
							 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFA,0x33,0xC0,0x8E,0xD0,0xBC,
							 0x00,0x7C,0xB8,0xB0,0x07,0x8E,0xD8,0x8E,0xC0,0xB9,0x00,0x01,0x8B,0xF1,0xBF,0x00,
							 0x03,0xF3,0xA5,0xB8,0xD0,0x07,0x50,0x8E,0xD8,0x8E,0xC0,0xB8,0x80,0x01,0x50,0xCB,
							 0xFB,0xBE,0x13,0x02,0xE8,0x3A,0x00,0xB8,0x01,0x02,0xB9,0x01,0x00,0xBA,0x80,0x00,
							 0x33,0xDB,0x8E,0xC3,0xBB,0x00,0x7C,0x06,0x53,0xCD,0x13,0x72,0x0A,0x26,0x81,0x3E,
							 0xFE,0x7D,0x55,0xAA,0x75,0x01,0xCB,0xBE,0xD0,0x01,0xE8,0x14,0x00,0xB4,0x01,0xCD,
							 0x16,0x74,0x06,0x32,0xE4,0xCD,0x16,0xEB,0xF4,0x32,0xE4,0xCD,0x16,0x33,0xD2,0xCD,
							 0x19,0xFC,0xAC,0x0A,0xC0,0x74,0x08,0x56,0xB4,0x0E,0xCD,0x10,0x5E,0xEB,0xF3,0xC3,
							 0x43,0x61,0x6E,0x6E,0x6F,0x74,0x20,0x6C,0x6F,0x61,0x64,0x20,0x66,0x72,0x6F,0x6D,
							 0x20,0x68,0x61,0x72,0x64,0x64,0x69,0x73,0x6B,0x2E,0x0D,0x0A,0x49,0x6E,0x73,0x65,
							 0x72,0x74,0x20,0x53,0x79,0x73,0x74,0x65,0x6D,0x64,0x69,0x73,0x6B,0x20,0x61,0x6E,
							 0x64,0x20,0x70,0x72,0x65,0x73,0x73,0x20,0x61,0x6E,0x79,0x20,0x6B,0x65,0x79,0x2E,
							 0x0D,0x0A,0x00,0x44,0x69,0x73,0x6B,0x20,0x66,0x6F,0x72,0x6D,0x61,0x74,0x74,0x65,
							 0x64,0x20,0x77,0x69,0x74,0x68,0x20,0x57,0x69,0x6E,0x49,0x6D,0x61,0x67,0x65,0x20,
							 0x36,0x2E,0x35,0x30,0x20,0x28,0x63,0x29,0x20,0x31,0x39,0x39,0x33,0x2D,0x32,0x30,
							 0x30,0x34,0x20,0x47,0x69,0x6C,0x6C,0x65,0x73,0x20,0x56,0x6F,0x6C,0x6C,0x61,0x6E,
							 0x74,0x0D,0x0A,0x73,0x65,0x65,0x20,0x68,0x74,0x74,0x70,0x3A,0x2F,0x2F,0x77,0x77,
							 0x77,0x2E,0x77,0x69,0x6E,0x69,0x6D,0x61,0x67,0x65,0x2E,0x63,0x6F,0x6D,0x0D,0x0A,
							 0x42,0x6F,0x6F,0x74,0x73,0x65,0x63,0x74,0x6F,0x72,0x20,0x66,0x72,0x6F,0x6D,0x20,
							 0x43,0x2E,0x48,0x2E,0x20,0x48,0x6F,0x63,0x68,0x73,0x74,0x61,0x74,0x74,0x65,0x72,
							 0x0D,0x0A,0x0D,0x0A,0x4E,0x6F,0x20,0x53,0x79,0x73,0x74,0x65,0x6D,0x64,0x69,0x73,
							 0x6B,0x2E,0x20,0x42,0x6F,0x6F,0x74,0x69,0x6E,0x67,0x20,0x66,0x72,0x6F,0x6D,0x20,
							 0x68,0x61,0x72,0x64,0x64,0x69,0x73,0x6B,0x2E,0x0D,0x0A,0x00,0x00,0x00,0x00,0x00,
							 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
							 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
							 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
							 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x55,0xAA};

static CHAR fake_device_0200[] = {0xFD,0xFF,0xFF,0xFF,0x0F};
static CHAR fake_device_0400[] = {0xFD,0xFF,0xFF,0xFF,0x0F};


static CHAR fake_device_0600[] =
                            {0x46,0x58,0x44,0x45,0x56,0x49,0x43,0x45,0x20,0x20,0x20,0x08,0x00,0x00,0x00,0x00,
       						 0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0xBF,0xEB,0x52,0x00,0x00,0x00,0x00,0x00,0x00,
       						 0x46,0x58,0x44,0x45,0x56,0x20,0x20,0x20,0x44,0x54,0x41,0x00,0x00,0x06,0x70,0xBF,
       						 0xEB,0x52,0x00,0x00,0x00,0x00,0x71,0xBF,0xEB,0x52,0x02,0x00,0x08,0x00,0x00,0x00,
       						 0x44,0x45,0x56,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x10,0x00,0x00,0x00,0x00,
       						 0x00,0x00,0x00,0x00,0x00,0x00,0x62,0x4F,0xEC,0x52,0x03,0x00,0x00,0x00,0x00,0x00};




static CHAR fake_device_1400[] = {0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

static CHAR fake_device_1800[] = {0x2E,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x10,0x00,0x00,0x00,0x00,
								  0x00,0x00,0x00,0x00,0x00,0x00,0x62,0x4F,0xEC,0x52,0x03,0x00,0x00,0x00,0x00,0x00,
								  0x2E,0x2E,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x10,0x00,0x00,0x00,0x00,
								  0x00,0x00,0x00,0x00,0x00,0x00,0x62,0x4F,0xEC,0x52,0x00,0x00,0x00,0x00,0x00,0x00,
								  0x44,0x45,0x56,0x31,0x33,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x08,0xBE,0x6A,0x47,
								  0xEC,0x52,0x00,0x00,0x00,0x00,0xF2,0x3E,0xEC,0x52,0x00,0x00,0x00,0x00,0x00,0x00,
								  0x44,0x45,0x56,0x31,0x34,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x08,0x81,0x6E,0x47,
								  0xEC,0x52,0x00,0x00,0x00,0x00,0xF2,0x3E,0xEC,0x52,0x00,0x00,0x00,0x00,0x00,0x00,
								  0x44,0x45,0x56,0x31,0x35,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x08,0x30,0x74,0x47,
								  0xEC,0x52,0x00,0x00,0x00,0x00,0xF2,0x3E,0xEC,0x52,0x00,0x00,0x00,0x00,0x00,0x00,
								  0x44,0x45,0x56,0x31,0x36,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x08,0x94,0x7B,0x47,
								  0xEC,0x52,0x00,0x00,0x00,0x00,0xF2,0x3E,0xEC,0x52,0x00,0x00,0x00,0x00,0x00,0x00,
								  0x44,0x45,0x56,0x30,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x08,0x9E,0xF1,0x3E,
								  0xEC,0x52,0x00,0x00,0x00,0x00,0xF2,0x3E,0xEC,0x52,0x00,0x00,0x00,0x00,0x00,0x00,
								  0x44,0x45,0x56,0x31,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x08,0x7C,0x04,0x3F,
								  0xEC,0x52,0x00,0x00,0x00,0x00,0xF2,0x3E,0xEC,0x52,0x00,0x00,0x00,0x00,0x00,0x00,
								  0x44,0x45,0x56,0x32,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x08,0x93,0x0C,0x3F,
								  0xEC,0x52,0x00,0x00,0x00,0x00,0xF2,0x3E,0xEC,0x52,0x00,0x00,0x00,0x00,0x00,0x00,
								  0x44,0x45,0x56,0x33,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x08,0x2A,0x12,0x3F,
								  0xEC,0x52,0x00,0x00,0x00,0x00,0xF2,0x3E,0xEC,0x52,0x00,0x00,0x00,0x00,0x00,0x00,
								  0x44,0x45,0x56,0x34,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x08,0xAD,0x15,0x3F,
								  0xEC,0x52,0x00,0x00,0x00,0x00,0xF2,0x3E,0xEC,0x52,0x00,0x00,0x00,0x00,0x00,0x00,
								  0x44,0x45,0x56,0x35,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x08,0xC7,0x19,0x3F,
								  0xEC,0x52,0x00,0x00,0x00,0x00,0xF2,0x3E,0xEC,0x52,0x00,0x00,0x00,0x00,0x00,0x00,
								  0x44,0x45,0x56,0x36,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x08,0x12,0x63,0x3F,
								  0xEC,0x52,0x00,0x00,0x00,0x00,0xF2,0x3E,0xEC,0x52,0x00,0x00,0x00,0x00,0x00,0x00,
								  0x44,0x45,0x56,0x37,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x08,0x2E,0x6C,0x3F,
								  0xEC,0x52,0x00,0x00,0x00,0x00,0xF2,0x3E,0xEC,0x52,0x00,0x00,0x00,0x00,0x00,0x00,
								  0x44,0x45,0x56,0x38,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x08,0x39,0x53,0x47,
								  0xEC,0x52,0x00,0x00,0x00,0x00,0xF2,0x3E,0xEC,0x52,0x00,0x00,0x00,0x00,0x00,0x00,
								  0x44,0x45,0x56,0x39,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x08,0x87,0x56,0x47,
								  0xEC,0x52,0x00,0x00,0x00,0x00,0xF2,0x3E,0xEC,0x52,0x00,0x00,0x00,0x00,0x00,0x00};

static CHAR fake_device_1A00[] = {0x44,0x45,0x56,0x31,0x30,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x08,0xB8,0x5B,0x47,
								  0xEC,0x52,0x00,0x00,0x00,0x00,0xF2,0x3E,0xEC,0x52,0x00,0x00,0x00,0x00,0x00,0x00,
								  0x44,0x45,0x56,0x31,0x31,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x08,0x55,0x62,0x47,
								  0xEC,0x52,0x00,0x00,0x00,0x00,0xF2,0x3E,0xEC,0x52,0x00,0x00,0x00,0x00,0x00,0x00,
								  0x44,0x45,0x56,0x31,0x32,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x08,0xBA,0x66,0x47,
								  0xEC,0x52,0x00,0x00,0x00,0x00,0xF2,0x3E,0xEC,0x52,0x00,0x00,0x00,0x00,0x00,0x00};


PFXDOSDEVICE FAR * k_dos_get_devices(VOID)
{
	return diskioDevices;
}

PFXDOSDEVICE k_dos_get_device(UINT index)
{
	return diskioDevices[index];
}

UINT k_dos_get_device_status(UINT index)
{
	return diskioDevices[index]->initialized;
}

/*-----------------------------------------------------------------------*/
/* Get Drive Status                                                      */
/*-----------------------------------------------------------------------*/

DSTATUS disk_status (
	BYTE pdrv		/* Physical drive nmuber to identify the drive */
)
{
	DSTATUS stat = STA_NOINIT;
	int result;

	//k_debug_hex("disk_status:",pdrv);

	switch (pdrv)
	{
	case 0x00:

		return RES_OK;
		break;
	case 0x03 :


		if(diskioDevices[pdrv] != NULL)
		{
			if(diskioDevices[pdrv]->initialized)
			{
				return RES_OK;
			}
		}

		return RES_OK;
		break;
	case 0x04 :


		if(diskioDevices[pdrv] != NULL)
		{
			if(diskioDevices[pdrv]->initialized)
			{
				return RES_OK;
			}
		}

		return RES_OK;

		break;
	case DEV_MMC :
		//result = MMC_disk_status();

		// translate the reslut code here

		return stat;

		break;
	case DEV_USB :
		//result = USB_disk_status();

		// translate the reslut code here

		return stat;
	}
	return STA_NOINIT;
}



/*-----------------------------------------------------------------------*/
/* Initialize a Drive                                                    */
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (
	BYTE pdrv				/* Physical drive nmuber to identify the drive */
)
{
	DSTATUS stat = STA_NOINIT;
	int result = 0;

	//k_debug_hex("disk_initialize:",pdrv);
	//k_debuginteger( "------- disk_initialize:dev:",pdrv);
	//k_debugstring("------- disk_initialize...\r\n");

	switch (pdrv)
	{
	case 0x00:

		return RES_OK;
		break;

	case 0x03 :
		if(diskioDevices[pdrv] == NULL)
		{
			//k_debug_hex("FIRST disk_initialize:",pdrv);
			diskioDevices[pdrv] =  k_create_dos_device(FXDOS_SDC);
		}
		else
		{
			if(diskioDevices[pdrv]->initialized != TRUE)
			{
				//k_debug_hex("RESTART disk_initialize:",pdrv);
				k_mem_deallocate_heap(diskioDevices[pdrv]);
				diskioDevices[pdrv] =  k_create_dos_device(FXDOS_SDC);
			}
		}

		if(diskioDevices[pdrv] && diskioDevices[pdrv]->initialized)
			stat = 0x00;
		else
			stat = STA_NOINIT;

		break;
	case 0x04:

		if(diskioDevices[pdrv] == NULL)
		{
			//k_debug_hex("FIRST HD disk_initialize:",pdrv);
			diskioDevices[pdrv] =  k_create_dos_device(FXDOS_HDD);
		}
		else
		{
			if(diskioDevices[pdrv]->initialized != TRUE)
			{
				//k_debug_hex("RESTART HD disk_initialize:",pdrv);
				k_mem_deallocate_heap(diskioDevices[pdrv]);
				diskioDevices[pdrv] =  k_create_dos_device(FXDOS_HDD);
			}
		}

		if(diskioDevices[pdrv] && diskioDevices[pdrv]->initialized)
			stat = 0x00;
		else
			stat = STA_NOINIT;


		break;
	case DEV_MMC :
		//result = MMC_disk_initialize();

		// translate the reslut code here

		//return stat;
		break;
	case DEV_USB :
		//result = USB_disk_initialize();

		// translate the reslut code here

		//return stat;
		break;
	}

	//k_debugstring("------- disk_initialize exit\r\n");

	return stat;
}



/*-----------------------------------------------------------------------*/
/* Read Sector(s)                                                        */
/*-----------------------------------------------------------------------*/

DRESULT disk_read (
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	BYTE *buff,		/* Data buffer to store read data */
	LBA_t sector,	/* Start sector in LBA */
	UINT count		/* Number of sectors to read */
)
{
	DRESULT res;
	int result = RES_PARERR;
	int i;

	//k_debug_integer( "------- disk_read:dev:",pdrv);
	//k_debug_long("------- disk_read:sector:",sector);
	//k_debug_integer("------- disk_read:count:",count);

	//k_debug_hex("disk_read:",pdrv);

	switch (pdrv)
	{
	case 0x00:

		k_debug_long("------- disk_read:RAM:sector:",sector);
		k_debug_integer("------- disk_read:RAM:count:",count);

		if(sector == 0)
		{
			memcpy(buff,fake_device_mbr,512);
		}
		else if(sector == 3)
		{
			memset(buff,0,512);
			memcpy(buff,fake_device_0600,sizeof(fake_device_0600));
		}
		else if(sector == 10)
		{
			memset(buff,0,512);
			memcpy(buff,fake_device_1400,sizeof(fake_device_1400));
		}
		else if(sector == 12)
		{
			memset(buff,0,512);
			memcpy(buff,fake_device_1800,sizeof(fake_device_1800));
		}
		else if(sector == 13)
		{
			memset(buff,0,512);
			memcpy(buff,fake_device_1A00,sizeof(fake_device_1A00));
		}
		res = RES_OK;
		break;

	case 0x03 :
		// translate the arguments here

		//k_debugpointer( "------- disk_read:diskioDevices[pdrv]:",diskioDevices[pdrv]);

		if(diskioDevices[pdrv]!=NULL)
		{
			//k_debugpointer( "------- disk_read:buff:",buff);

			for(i=0;i<count;i++)
			{
				//if(count > 1)
				//{
				//	k_debug_integer( "------- disk_read:dev:count:",i);
				//}
				diskioDevices[pdrv]->pfReader((sector + i) * 512,buff);
				buff+=512;
			}
			//k_debugbyte_array("------- disk_read:buff:data:\r\n",buff,512);

			//result = RAM_disk_read(buff, sector, count);

			// translate the reslut code here

			res = RES_OK;
		}
		break;

	case 0x04 :
		// translate the arguments here

		//k_debugpointer( "------- disk_read:diskioDevices[pdrv]:",diskioDevices[pdrv]);

		if(diskioDevices[pdrv]!=NULL)
		{
			//k_debugpointer( "------- disk_read:buff:",buff);

			for(i=0;i<count;i++)
			{
				//if(count > 1)
				//{
				//	k_debug_integer( "------- disk_read:dev:count:",i);
				//}
				diskioDevices[pdrv]->pfReader((sector + i),buff);
				buff+=512;
			}
			//k_debugbyte_array("------- disk_read:buff:data:\r\n",buff,512);

			//result = RAM_disk_read(buff, sector, count);

			// translate the reslut code here

			res = RES_OK;
		}
		break;

	case DEV_MMC :
		// translate the arguments here

		//result = MMC_disk_read(buff, sector, count);

		// translate the reslut code here

		//return res;
		break;
	case DEV_USB :
		// translate the arguments here

		//result = USB_disk_read(buff, sector, count);

		// translate the reslut code here

		//return res;
		break;
	}

	//k_debugstring("------- disk_read exit\r\n");

	return res;
}



/*-----------------------------------------------------------------------*/
/* Write Sector(s)                                                       */
/*-----------------------------------------------------------------------*/

#if FF_FS_READONLY == 0

DRESULT disk_write (
	BYTE pdrv,			/* Physical drive nmuber to identify the drive */
	const BYTE *buff,	/* Data to be written */
	LBA_t sector,		/* Start sector in LBA */
	UINT count			/* Number of sectors to write */
)
{
	int i = 0;
	DRESULT res = RES_PARERR;
	int result;

	//k_debug_integer("------- disk_write:dev:",pdrv);
	//k_debug_integer("------- disk_write::count:",count);

	switch (pdrv)
	{
	case 0x00:

		k_debug_long("------- disk_write:RAM:sector:",sector);
		k_debug_integer("------- disk_write:RAM:count:",count);


		k_debug_byte_array("------- disk_write:DATA:",(PBYTE)buff,512);
		/*
		if(sector == 0)
		{
			memcpy(buff,fake_device_mbr,512);
		}
		else if(sector == 3)
		{
			memset(buff,0,512);
			memcpy(buff,fake_device_0600,sizeof(fake_device_0600));
		}
		else if(sector == 10)
		{
			memset(buff,0,512);
			memcpy(buff,fake_device_1400,sizeof(fake_device_1400));
		}
		*/

		res = RES_OK;


		res = RES_OK;
		break;

	case 0x03 :

		if(diskioDevices[pdrv] && diskioDevices[pdrv]->pfWriter)
		{
			// translate the arguments here
			for(i=0;i<count;i++)
			{
				result = diskioDevices[pdrv]->pfWriter((sector+(ULONG)i)*512L,(BYTE*)buff);
				if(result)
				{
					return RES_PARERR;
				}
				buff+=512L;
			}
			// translate the result code here
		}
		res = 0;

		break;
	case 0x04 :

		if(diskioDevices[pdrv] && diskioDevices[pdrv]->pfWriter)
		{
			// translate the arguments here
			for(i=0;i<count;i++)
			{
				result = diskioDevices[pdrv]->pfWriter(sector+((ULONG)i),(BYTE*)buff);
				if(result)
				{
					return RES_PARERR;
				}
				buff+=512;
			}
			// translate the reslut code here
		}
		res = 0;

		break;
	case DEV_MMC :
		// translate the arguments here

		//result = MMC_disk_write(buff, sector, count);

		// translate the reslut code here

		return res;

	case DEV_USB :
		// translate the arguments here

		//result = USB_disk_write(buff, sector, count);

		// translate the reslut code here

		return res;
	}

	//k_debugstring("------- disk_write exit\r\n");

	return res;
}

#endif


/*-----------------------------------------------------------------------*/
/* Miscellaneous Functions                                               */
/*-----------------------------------------------------------------------*/

DRESULT disk_ioctl (
	BYTE pdrv,		/* Physical drive nmuber (0..) */
	BYTE cmd,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
	DRESULT res;
	int result;

	//k_debug_hex("disk_ioctl::pdrv:",pdrv);
	//k_debug_hex("disk_ioctl::cmd:",cmd);

	switch (pdrv)
	{
	case 0x00:

		res = RES_OK;
		break;

	case 0x03 :

		//diskioDevices[pdrv]->pfWriter(sector,(BYTE*)buff);

		return RES_OK;

	case 0x04 :

		//diskioDevices[pdrv]->pfWriter(sector,(BYTE*)buff);

		return RES_OK;
	case DEV_MMC :

		// Process of the command for the MMC/SD card

		return res;

	case DEV_USB :

		// Process of the command the USB drive

		return res;
	}

	return RES_PARERR;
}
#else



/*-----------------------------------------------------------------------*/
/* Get Drive Status                                                      */
/*-----------------------------------------------------------------------*/

DSTATUS disk_status (
	BYTE pdrv		/* Physical drive nmuber to identify the drive */
)
{
	k_debug_hex("disk_status::pdrv:",pdrv);
	return RES_OK;
}



/*-----------------------------------------------------------------------*/
/* Inidialize a Drive                                                    */
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (
	BYTE pdrv				/* Physical drive nmuber to identify the drive */
)
{
	return STA_NOINIT;
}



/*-----------------------------------------------------------------------*/
/* Read Sector(s)                                                        */
/*-----------------------------------------------------------------------*/

DRESULT disk_read (
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	BYTE *buff,		/* Data buffer to store read data */
	LBA_t sector,	/* Start sector in LBA */
	UINT count		/* Number of sectors to read */
)
{
	//k_debugstring("------- disk_read exit\r\n");

	return RES_PARERR;
}



/*-----------------------------------------------------------------------*/
/* Write Sector(s)                                                       */
/*-----------------------------------------------------------------------*/

#if FF_FS_READONLY == 0

DRESULT disk_write (
	BYTE pdrv,			/* Physical drive nmuber to identify the drive */
	const BYTE *buff,	/* Data to be written */
	LBA_t sector,		/* Start sector in LBA */
	UINT count			/* Number of sectors to write */
)
{
	//k_debugstring("------- disk_write exit\r\n");

	return RES_PARERR;
}

#endif


/*-----------------------------------------------------------------------*/
/* Miscellaneous Functions                                               */
/*-----------------------------------------------------------------------*/

DRESULT disk_ioctl (
	BYTE pdrv,		/* Physical drive nmuber (0..) */
	BYTE cmd,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
	return RES_PARERR;
}


#endif
